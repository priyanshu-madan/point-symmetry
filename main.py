from shapely.geometry import MultiPoint
import matplotlib.pyplot as plt
import numpy as np
from decimal import Decimal as D
from symmetry_inputs import take_input


def get_centroid():
    '''
    This function finds the centroid of the input coordinates

    Returns (x,y) centroid coordinates
    '''
    points = MultiPoint(input_points)
    centroid = points.centroid.xy
    x1, y1 = centroid[0][0], centroid[1][0]
    return (x1,y1)


def mirrorImage(a, b, c, original_point):
    '''
    This function finds coordinates of the mirror image of the input point across the line (ax + by + c = 0).

    :param a: coefficient of straight line
    :param b: coefficient of straight line
    :param c: coefficient of straight line
    :param original_point: input point
    :return: reflection coordinates of original point
    '''

    x3, y3 = D(str(original_point[0])),D(str(original_point[1]))
    a,b,c = D(str(a)), D(str(b)), D(str(c))

    temp = -2 * ((a * x3 + b * y3 + c) / (a * a + b * b))
    x = (temp * a + x3).quantize(precision)
    y = (temp * b + y3).quantize(precision)
    return (float(x),float(y))


def find_midpoints():
    '''
    This function calculates the mid points coordinates of all the input coordinates
    These coordinates are appended to mid_point list
    :return: None
    '''
    for i in range(len(input_points)):
        for j in range(i+1,len(input_points)):
            mp = ((input_points[i][0] + input_points[j][0]) / 2 , (input_points[i][1] + input_points[j][1]) / 2 )
            if mp not in mid_points and mp != centroid:
                mid_points.append(mp)


def line_of_reflection():
    '''
    This function finds all possible line of reflections for the given input coordinates.
    :return:
    '''
    for each in full_points:
        reflection_stack = []
        check = True

        x2,y2 = each

        if x1 == x2 and y1 == y2:
            continue
        a = y1 - y2
        b = x2 - x1
        c = (x1 - x2) * y1 + (y2 - y1) * x1


        vector_1 = (x1 - x2, y1 - y2)

        for point in input_points:
            if point in reflection_stack or point == each:
                continue
            else:
                # cross product to check if the input point is on line of reflection
                vector_2 = (x1 - point[0],y1 - point[1])
                xp = vector_1[0] * vector_2[1] - vector_1[1] * vector_2[0]
                if xp == 0:
                    continue

                # find the mirror image of input points
                mirror = mirrorImage(a,b,c,point)

                # check if mirror is in input points
                if  mirror in input_points:
                    # mirror image is found
                    if mirror not in reflection_stack:
                        reflection_stack.append(mirror)
                else:
                    # mirror image is not found, break out of the current loop
                    check = False
                    break

        # if all points are reflected, remove duplicate lines and append (a,b,c) coefficients to required_list list
        if check:
            if a==0 and c == 0:
                if (0,1,0) not in required_lines:
                    required_lines.append((0, 1, 0))
            elif b == 0 and c == 0:
                if (1, 0, 0) not in required_lines:
                    required_lines.append((1, 0, 0))
            elif a ==0 and b !=0 and c != 0:
                b = b/(c)
                c = 1
                if (a,b,c) not in required_lines:
                    required_lines.append((a, b, c))
            elif b ==0 and a !=0 and c != 0:
                a = a/(c)
                c = 1
                if (a, b, c) not in required_lines:
                    required_lines.append((a, b, c))
            elif c == 0 and a !=0 and b != 0:
                a = a/(b)
                b = 1
                if (a, b, c) not in required_lines:
                    required_lines.append((a, b, c))
            else:
                a = a/(c)
                b = b/(c)
                c = 1
                if (a, b, c) not in required_lines:
                    required_lines.append((a, b, c))


def plot_lines(input_line):
    '''
    This function takes in the lines generated by lines of reflection function.
    prints out the line equation and plots the lines on a graph

    :param input_line:
    :return:
    '''
    line_x = np.linspace(min_x, max_x, 100)
    a,b,c = input_line
    if b == 0:
        plt.axvline(x=x1)
        print("line found: x=" + str(x1))
    else:
        equation = (-(a * line_x + c)) / b
        print("line found: (" + str(a) + ")x + (" + str(b) + ")y + (" + str(c) + ") = 0")
        plt.plot(line_x, equation)




if __name__ == '__main__':


    mid_points = []
    duplicate_lines = []
    required_lines =[]
    precision = D(10) ** -16

    # Take user input
    input_points = take_input()

    # find minimum, maximum x values (for plotting purposes)
    min_x = min(input_points, key=lambda x: x[0])[0]
    max_x = max(input_points, key=lambda x: x[0])[0]


    # calculate centroid of the points
    centroid = get_centroid()
    x1,y1 = centroid

    # find out mid points of input points
    find_midpoints()
    full_points = list(set(mid_points + input_points))


    # find required lines of reflections
    line_of_reflection()

    # plot input points, centroid on graph
    plt.scatter(x1, y1)
    plt.scatter(*zip(*input_points))
    # plt.scatter(*zip(*mid_points))

    print("===============================")
    print("Total number of lines found: %d" %len(required_lines))
    print("===============================")

    # plotting/printing all possible lines of reflection
    for each in required_lines:
        plot_lines(each)
    plt.savefig("./output/graphs.png")
    plt.show()



